/**
 * Workflow Validation Utility
 *
 * Validates AI-generated workflows against schema rules.
 * Based on: /specs/001-ai-workflow-generation/research.md Q3
 */

import {
  type Connection,
  NodeType,
  VALIDATION_RULES,
  type Workflow,
  type WorkflowNode,
} from '../../shared/types/workflow-definition';

export interface ValidationError {
  code: string;
  message: string;
  field?: string;
}

export interface ValidationResult {
  valid: boolean;
  errors: ValidationError[];
}

/**
 * Validate a workflow generated by AI
 *
 * @param workflow - The workflow object to validate
 * @returns Validation result with errors if invalid
 */
export function validateAIGeneratedWorkflow(workflow: unknown): ValidationResult {
  const errors: ValidationError[] = [];

  // Type check: Is it an object?
  if (typeof workflow !== 'object' || workflow === null) {
    return {
      valid: false,
      errors: [{ code: 'INVALID_TYPE', message: 'Workflow must be an object' }],
    };
  }

  const wf = workflow as Partial<Workflow>;

  // Required fields check
  if (!wf.id || typeof wf.id !== 'string') {
    errors.push({ code: 'MISSING_FIELD', message: 'Workflow must have an id', field: 'id' });
  }

  if (!wf.name || typeof wf.name !== 'string') {
    errors.push({ code: 'MISSING_FIELD', message: 'Workflow must have a name', field: 'name' });
  }

  if (!wf.version || typeof wf.version !== 'string') {
    errors.push({
      code: 'MISSING_FIELD',
      message: 'Workflow must have a version',
      field: 'version',
    });
  } else if (!VALIDATION_RULES.WORKFLOW.VERSION_PATTERN.test(wf.version)) {
    errors.push({
      code: 'INVALID_FORMAT',
      message: 'Version must follow semantic versioning (e.g., 1.0.0)',
      field: 'version',
    });
  }

  if (!Array.isArray(wf.nodes)) {
    errors.push({
      code: 'MISSING_FIELD',
      message: 'Workflow must have a nodes array',
      field: 'nodes',
    });
    // Cannot continue validation without nodes
    return { valid: false, errors };
  }

  if (!Array.isArray(wf.connections)) {
    errors.push({
      code: 'MISSING_FIELD',
      message: 'Workflow must have a connections array',
      field: 'connections',
    });
  }

  // Node count validation
  if (wf.nodes.length > VALIDATION_RULES.WORKFLOW.MAX_NODES) {
    errors.push({
      code: 'MAX_NODES_EXCEEDED',
      message: `Generated workflow exceeds maximum node limit (${VALIDATION_RULES.WORKFLOW.MAX_NODES}). Please simplify your description.`,
      field: 'nodes',
    });
  }

  // Node-specific validation
  const nodeErrors = validateNodes(wf.nodes);
  errors.push(...nodeErrors);

  // Connection validation (only if connections array exists)
  if (Array.isArray(wf.connections)) {
    const connectionErrors = validateConnections(wf.connections, wf.nodes);
    errors.push(...connectionErrors);
  }

  // Start/End node validation
  const startNodes = wf.nodes.filter((n) => n.type === NodeType.Start);
  const endNodes = wf.nodes.filter((n) => n.type === NodeType.End);

  if (startNodes.length === 0) {
    errors.push({
      code: 'MISSING_START_NODE',
      message: 'Workflow must have at least one Start node',
    });
  }

  if (startNodes.length > 1) {
    errors.push({
      code: 'MULTIPLE_START_NODES',
      message: 'Workflow must have exactly one Start node',
    });
  }

  if (endNodes.length === 0) {
    errors.push({
      code: 'MISSING_END_NODE',
      message: 'Workflow must have at least one End node',
    });
  }

  return {
    valid: errors.length === 0,
    errors,
  };
}

/**
 * Validate all nodes in the workflow
 */
function validateNodes(nodes: WorkflowNode[]): ValidationError[] {
  const errors: ValidationError[] = [];
  const nodeIds = new Set<string>();

  for (const node of nodes) {
    // Check for duplicate IDs
    if (nodeIds.has(node.id)) {
      errors.push({
        code: 'DUPLICATE_NODE_ID',
        message: `Duplicate node ID: ${node.id}`,
        field: `nodes[${node.id}]`,
      });
    }
    nodeIds.add(node.id);

    // Validate node name
    if (!node.name || !VALIDATION_RULES.NODE.NAME_PATTERN.test(node.name)) {
      errors.push({
        code: 'INVALID_NODE_NAME',
        message: `Node name must match pattern ${VALIDATION_RULES.NODE.NAME_PATTERN}`,
        field: `nodes[${node.id}].name`,
      });
    }

    // Validate node type
    if (!Object.values(NodeType).includes(node.type)) {
      errors.push({
        code: 'INVALID_NODE_TYPE',
        message: `Invalid node type: ${node.type}`,
        field: `nodes[${node.id}].type`,
      });
    }

    // Validate position
    if (
      !node.position ||
      typeof node.position.x !== 'number' ||
      typeof node.position.y !== 'number'
    ) {
      errors.push({
        code: 'INVALID_POSITION',
        message: 'Node must have valid position with x and y coordinates',
        field: `nodes[${node.id}].position`,
      });
    }
  }

  return errors;
}

/**
 * Validate all connections in the workflow
 */
function validateConnections(connections: Connection[], nodes: WorkflowNode[]): ValidationError[] {
  const errors: ValidationError[] = [];
  const nodeIds = new Set(nodes.map((n) => n.id));
  const connectionIds = new Set<string>();

  for (const conn of connections) {
    // Check for duplicate connection IDs
    if (connectionIds.has(conn.id)) {
      errors.push({
        code: 'DUPLICATE_CONNECTION_ID',
        message: `Duplicate connection ID: ${conn.id}`,
        field: `connections[${conn.id}]`,
      });
    }
    connectionIds.add(conn.id);

    // Validate from/to node IDs exist
    if (!nodeIds.has(conn.from)) {
      errors.push({
        code: 'INVALID_CONNECTION',
        message: `Connection references non-existent from node: ${conn.from}`,
        field: `connections[${conn.id}].from`,
      });
    }

    if (!nodeIds.has(conn.to)) {
      errors.push({
        code: 'INVALID_CONNECTION',
        message: `Connection references non-existent to node: ${conn.to}`,
        field: `connections[${conn.id}].to`,
      });
    }

    // Validate no self-connections
    if (conn.from === conn.to) {
      errors.push({
        code: 'SELF_CONNECTION',
        message: 'Node cannot connect to itself',
        field: `connections[${conn.id}]`,
      });
    }

    // Validate Start/End node connection rules
    const fromNode = nodes.find((n) => n.id === conn.from);
    const toNode = nodes.find((n) => n.id === conn.to);

    if (toNode?.type === NodeType.Start) {
      errors.push({
        code: 'INVALID_CONNECTION',
        message: 'Start node cannot have input connections',
        field: `connections[${conn.id}]`,
      });
    }

    if (fromNode?.type === NodeType.End) {
      errors.push({
        code: 'INVALID_CONNECTION',
        message: 'End node cannot have output connections',
        field: `connections[${conn.id}]`,
      });
    }
  }

  // Check for cycles (simplified check - full cycle detection would be more complex)
  // For MVP, we'll rely on the AI to generate acyclic workflows

  return errors;
}
